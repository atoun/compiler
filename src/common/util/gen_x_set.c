
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "string_case.h"

#define MAX_LEN 260

int debug = 0;

FILE *Init(char *filename);
void Filter(FILE* outfile, char *infilename);;

int opt_s = 0, opt_f = 0;
char *utildir, *filename, *base_type, *num_elt, *elt_num, *uset_type, *lset_type, *sub_elt_num, *sub_num_elt;

int main(int argc, char * argv[])
{
    int i, headers;
    char *set_type, *rev, *itype;
    FILE *outfile;
    char filenamebuf[MAX_LEN];

fprintf(stderr, "\n\n\n-----------gen_x_set---------------------------------------\n");

    for (i = 1; i < argc; i++)
    {
        if (strcmp(argv[i], "-f") == 0) opt_f = 1;
        else if (strcmp(argv[i], "-s") == 0)
        {
            fprintf(stderr, "found -s\n");
            opt_s = 1;
        }
        else break;
    }

    utildir = argv[i++];
    filename = argv[i++];
    base_type = argv[i++];
    set_type = argv[i++];
    elt_num = argv[i++];
    num_elt = argv[i++];

fprintf(stderr, "utildir='%s'\n", utildir);
fprintf(stderr, "filename='%s'\n", filename);
fprintf(stderr, "base_type='%s'\n", base_type);
fprintf(stderr, "set_type='%s'\n", set_type);

    uset_type = malloc(strlen(set_type) + 1);
    strcpy(uset_type, set_type);
    string_toupper(uset_type);
    lset_type = malloc(strlen(set_type) + 1);
    strcpy(lset_type, set_type);
    string_tolower(lset_type);

    // Generate the subuniverse relative forms?
    if (opt_s)
    {
        sub_elt_num = argv[i++];
        sub_num_elt = argv[i++];
        headers += 2;
    }
    else
    {
        // We need strings for the substitution below.  This will be harmless:
        sub_elt_num = "#sub_elt_num#";
        sub_num_elt = "#sub_num_elt#";
    }

    headers = i;
    if (headers > argc)
    {
        fprintf(stderr, "failure!\n");
        return -1;
    }

    // Macro or functional interface?
    itype = opt_f ? "func" : "macro";

    rev = "$Revision$";

    // Write the .cxx file.
    sprintf(filenamebuf, "%s.cxx", filename);
    outfile = Init(filenamebuf);
    for (i = headers; i < argc; i++)
    {
        fprintf(outfile, "#include \"%s\"\n", argv[i]);
    }
    sprintf(filenamebuf, "%s/x_set_%s.c", utildir, itype);
    Filter(outfile, filenamebuf);
    fclose(outfile);

    // Write the .h file
    sprintf(filenamebuf, "%s.h", filename);
    outfile = Init(filenamebuf);
    sprintf(filenamebuf, "%s/x_set_interface", utildir);
    Filter(outfile, filenamebuf);
    sprintf(filenamebuf, "%s/x_set_%s.h", utildir, itype);
//if (strcmp(filename, "bb_set") == 0) debug = 1;
//fprintf(stderr, ">>>>>>>>>>>>>>>>>>>>>>>>>>>>>  infile='%s', outfile='%s'\n", filenamebuf, filenamebuf);
    Filter(outfile, filenamebuf);
//debug = 0;
    fclose(outfile);

    // write the .td file
    sprintf(filenamebuf, "%s.td", filename);
    outfile = Init(filenamebuf);
    sprintf(filenamebuf, "%s/x_set_%s.td", utildir, itype);
    Filter(outfile, filenamebuf);
    fclose(outfile);

    return 0;
}


// Initialize and open the file
FILE *Init(char *filename)
{
    FILE *outfile;

    outfile = fopen(filename, "w");
    //if (outfile) fprintf(outfile, "/* Generated by gen_s_set $rev */\n");
    return outfile;
}

// FIXME: check for buffer overflow
void replace(char *buffer, char *pattern, char *replace)
{
    char tmpbuf[MAX_LEN];
    char *str;

    str = buffer;
    while (str = strstr(str, pattern))
    {
        int len = str - buffer;
        strncpy(tmpbuf, buffer, len);
        strcpy(tmpbuf + len, replace);
        str += strlen(pattern);
        strcat(tmpbuf, str);
        strcpy(buffer, tmpbuf);
    }
}

// Filter the input files into the OF.  Everything above the "BEGIN" line
// is stripped.  If a RCS revision is found, it is passed along as a comment.
// All the instances of the #..# names are replaced.
void Filter(FILE* outfile, char *infilename)
{
    FILE *infile;
    int i, subu = 0;
    char buffer[MAX_LEN];
    char *str;
    char filebuf[BUFSIZ];

    infile = fopen(infilename, "r");
    if (!infile)
    {
        fprintf(stderr, "Error: failed to open file '%s' for reading.\n", infilename);
        exit(-1);
    }
    setbuf(infile, filebuf);

    if (!outfile)
    {
        fprintf(stderr, "Error: no output file\n");
        exit(-1);
    }

    while (fgets(buffer, MAX_LEN, infile))
    {
        for (i = 0; i < strlen(buffer); i++)
            if (buffer[i]==13 || buffer[i]==10) buffer[i]='\0';

        if (strcmp(buffer, "BEGIN") == 0)
        {
            if (debug) fprintf(stderr, "BEGIN\n");
            break;
        }
        else if (str = strstr(buffer, "$Revision: "))
        {
            strncpy(buffer, str + 11, 5);
            buffer[5] = '\0';
            fprintf(outfile, "/* Generated from %s Rev %s */\n", infilename, buffer);
        }
        else if (debug) fprintf(stderr, "line1: %s\n", buffer);
    }

    while (fgets(buffer, MAX_LEN, infile))
    {
        for (i = 0; i < strlen(buffer); i++)
            if (buffer[i]==13 || buffer[i]==10) buffer[i]='\0';

//if (debug) fprintf(stderr, "line2: %s\n", buffer);

        if (strcmp(buffer, "BEGIN SUBUNIVERSES") == 0)
        {
            subu = 1;
            continue;
        }
        else if (strcmp(buffer, "END SUBUNIVERSES") == 0)
        {
            subu = 0;
            continue;
        }
        else if (subu && !opt_s)
        {
            continue;
        }

        replace(buffer, "#base_type#", base_type);
        replace(buffer, "#num_elt#", num_elt);
        replace(buffer, "#elt_num#", elt_num);
        replace(buffer, "#uset#", uset_type);
        replace(buffer, "#lset#", lset_type);
        replace(buffer, "#filename#", filename);
        replace(buffer, "#elt_num_sub#", sub_elt_num);
        replace(buffer, "#num_elt_sub#", sub_num_elt);

        //fprintf(stderr, "%s\n", buffer);
        fprintf(outfile, "%s\n", buffer);
    }

    fclose(infile);
}
