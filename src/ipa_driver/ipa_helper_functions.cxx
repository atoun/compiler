/*
   Copyright (C) 2010 PathScale Inc. All Rights Reserved.
*/
/*
 * Copyright (C) 2006, 2007. PathScale Inc. All Rights Reserved.
 */

/*

   Path64 is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation version 3

   Path64 is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with Path64; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
   02110-1301, USA.

*/
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>

#include "ipa_command_line.h"


static int tmpdir_length = 0;
static mode_t cmask = 0;	    /* file creation mode mask */

extern char *tmpdir;
extern char *outfilename;

static char **tmp_list = 0;
static int tmp_list_size = 0;
static int tmp_list_max = 0;

#define DEFAULT_TMP_LIST_SIZE 32
#define DEFAULT_TMPDIR "./ldtmp"

/*******************************************************
	Function: concat_names

	Create a new string by concating 2 other strings.

 *******************************************************/
char * concat_names(const char * name1, const char * name2)
{
    char *mangled_name = NULL;
    int len = strlen(name1)+strlen(name2)+1;

    mangled_name = (char *)malloc(len);
    MALLOC_ASSERT(mangled_name);

    strcpy(mangled_name, name1);
    strcat(mangled_name, name2);

    return(mangled_name);
}

/*
 * Maintain list of temp. files created so they are all removed on error or
 * when done.  Assume the first entry is "tmpdir".
 */
void add_to_tmp_file_list (char * path)
{
    if (tmp_list_max == 0) {
	tmp_list_max = DEFAULT_TMP_LIST_SIZE;
	tmp_list = (char**) malloc (tmp_list_max * sizeof(char*));
	MALLOC_ASSERT (tmp_list);
    } else if (tmp_list_size >= tmp_list_max) {
	tmp_list_max *= 2;
	tmp_list = (char**)realloc (tmp_list, tmp_list_max * sizeof(char*));
	MALLOC_ASSERT (tmp_list);
    }

    tmp_list[tmp_list_size++] = path;

} /* add_to_tmp_file_list */


/* ====================================================================
 *
 * create_tmpdir
 *
 * Create a temporary directory for (1) relocatable objects generated
 * from the backend under IPA control, (2) IR objects extracted from an
 * archive, and (3) IR objects generated by IPA.
 *
 * There are three cases.  If this is a directory to be kept, because
 * either -keep or a trace flag is specified for an IPA build, then the
 * directory is named <outfilename>.ipakeep, and if it already exists,
 * all files are cleared from it.  If it is a temporary directory for
 * an IPA build, a unique name is used with the template
 * $TMPDIR/<outfilename_with_path_stripped>.ipaXXXXXX .  For a normal link, 
 * a temporary directory
 * is created in the DEFAULT_TMPDIR with the name template XXXXXX.
 *
 * ====================================================================
 */

int
create_tmpdir ( int tracing )
{
    int fixedname =  ipa_opt[IPA_KEEP_TEMPS].flag;

    if ( fixedname ) {
        tmpdir = concat_names ( outfilename, ".ipakeep" );
    } else {
        char *tmpdir_env_var;
        if ((tmpdir_env_var = getenv("TMPDIR")) != NULL) {
    	char *filename;
            tmpdir_env_var = concat_names ( tmpdir_env_var, "/");
    	if ((filename = strrchr(outfilename, '/')) != NULL)
    	    filename++;
    	else
    	    filename = outfilename;
    	
            tmpdir = concat_names ( tmpdir_env_var, filename);
        }
        else
            tmpdir = outfilename;
        tmpdir = concat_names ( tmpdir, ".ipaXXXXXX" );
    }
    if ( ! fixedname ) {
	tmpdir = mktemp ( tmpdir );
    }
    tmpdir_length = strlen ( tmpdir );

    if ( cmask == 0 ) {
	cmask = umask (0);
	(void) umask (cmask);
    }

    if ( mkdir (tmpdir, 0777 & ~cmask) != 0 ) {
	if ( errno == EEXIST && fixedname ) {
	    /* We have an old instance of this directory -- clear it out: */
	    DIR *dirp;
	    struct dirent *entryp;
	    char *prefix;

	    dirp = opendir ( tmpdir );
	    if ( dirp != NULL ) {
		prefix = concat_names ( tmpdir, "/" );
		while ( ( entryp = readdir(dirp) ) != NULL ) {
		    /* Don't bother with names of one or two characters, e.g. '.'
		     * and '..', since we don't create temporary files with such
		     * names:
		     */
#ifdef _D_EXACT_NAMLEN
		  if (_D_EXACT_NAMLEN(entryp) > 2)
#elif defined(__sun)
		  if ( entryp->d_reclen > 2 )
#else
		  if ( entryp->d_namlen > 2 )
#endif
		    {
			char * fname = concat_names ( prefix, entryp->d_name);
			unlink (fname);
			free (fname);
		    }
		}
		free (prefix);
		closedir ( dirp );
	    }
	} else {
    	    perror("cannot create temporary directory for code generation");
	    return -1;
	}
    }

    add_to_tmp_file_list ( tmpdir );

    return 0;

} /* create_tmpdir */
